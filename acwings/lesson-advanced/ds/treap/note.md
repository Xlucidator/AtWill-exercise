## 平衡树

算法竞赛中常用：**Treap**(BBST+堆)、红黑树(太麻烦，用set/map代劳)、**Splay**(最常用)、SBT(不常用)、AVL

Splay提高不介绍，进阶介绍；此处位Treap

### Treap

BBST：一般权值互异；中序遍历单调；

- 本质：**动态维护有序序列** 
- 操作：插入、删除、找前驱/后继（前驱后继定义在 中序遍历序列 中）、找最值
  - 前驱
    - 有左子树：则找左子树的最大值，即从左子树开始向右走到头
    - 无左子树：找第一个身为其右子树节点的父节点，即不断遍历父节点，直到父节点是向左拐的（成右子树）
  - 后驱类似
  - 以上操作在set中均有实现：insert, erase, ++/--, begin()/end()-1
- 操作：set中不存在，需手写
  - **求某个值的排名**（set中节点没有这个信息）
  - **求排名是k的数**（即nth_element)
  - **比某个数小的最大值**（lower_bound/upper_bound) 
  - **比某个数大的最小值** ：并非找前驱和后继，这是对值进行query，值可能不在

具体实现在Treap中

Treap：最简单的BBST 

- 原理：使BST尽量随机，随机BST的期望高度O(log n)

- 节点结构

  ```cpp
  struct Node {
      int l, r;
      int key;  // BST中key有序
      int val;  // Heap中val满足堆序性（以大根为例）
  } tr[N]; // 空间复杂度O(n)
  ```

- 初始化：一般会加两个哨兵，-infinity和+infinity

- 左旋zig，右旋zag：不破坏BST中序性质，但是可以交换两个节点（**从而满足堆序性**）

  ```
        x        zig        y
       / \       ==>       / \
      y   T3     <==      T1  x
     / \         zag         / \
   T1   T2                  T2 T3
  ```
  
  这里为还是想把zig认作左旋（和yxc讲的不一样），与学ds时的认知一致；然后有**往哪侧旋，哪侧的值就会上升一层，另一侧下降**
- 删除：针对要删除的节点，不断旋转将其旋转至叶节点，然后删去；旋转时注意将大val向上转（即向大val处旋）



#### 254. 普通平衡树

BBST模板题

您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1. 插入数值 x。
2. 删除数值 x(若有多个相同的数，应只删除一个)。
3. 查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4. 查询排名为 x 的数值。
5. 求数值 x 的前驱(前驱定义为小于 x 的最大的数)。(并非节点前后驱)
6. 求数值 x 的后继(后继定义为大于 x 的最小的数)。

数据保证查询的结果一定存在。

---

实现

- 尽管用递归，logn的树高，不可能爆栈
- debug：`getKeyByRank`递归时函数写成了`getRankByKey`，真乃灯下黑，看了好几遍都每发现



#### 265. 营业额统计

计算最小波动。即对于a[i]来说，寻找a[1]～a[i-1]中和a[i]差最小得一个a[j] $\iff$ 找大于等于a[i]得最小数，和小于等于a[i]得最大数，两个差取min即可

求最小波动值之和

