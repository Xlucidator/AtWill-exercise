### 734. 能量石

只能一次吃一块能量石，吃每块都需要时间，能量石在没被吃时能量会耗散；求最大能量的吃法

很像OS的进程调度，感觉就可以作为某种调度策略。贪心 + dp

125.耍杂技的牛 + 01背包

#### 自己分析

即**求最小耗散**，只需要关注$L_i$（能量耗散速率）和$S_i$（吃的时间）

同125分析方式，若仅关注两块相邻的石头$i, j$ ；它们两的交换并不会影响其他部分耗散变化
- 若排序为$i,j$：则耗散的能量为$S_i \cdot L_j$ 
- 若排序为$j,i$：则耗散的能量为$S_j \cdot L_i$ 
- OPT肯定是某种排序，然后不会了：<font color="red">不应该</font>
	- 即OPT肯定有$S_i\cdot L_j < S_j \cdot L_i \iff \frac{S_i}{L_i} < \frac{S_j}{L_j}$ ，这样就可以排序了
	- 就是之前的分析方式，给忘了变形处理

还需要注意耗散有上界，减到能量为0就不会再继续了，所以$E_i$也是需要关注的

#### 分析

显然不应该再完全像125那样想：直接dp不好，直接贪心出不来 $\to$ 是贪心后再dp
能量为0的直接不考虑不吃即可 $\to$ 考察**选定子集**

还是分析两块相邻的石头 $i, i+1$；记此时两块石头的能量为$E_i', E_{i+1}'$，均大于0（等于0的排除）
- $i, i+1$排序：能量为$E_i' + E_{i+1}' - S_i\cdot L_j$ 
- $i+1, i$排序：能量为$E_i'+E_{i+1}'-S_j\cdot L_i$ 
- 然后**同上分析**得到OPT情况满足良好的性质，即可按$S_i / L_i$进行升序排列

还需要dp的原因就在于这个耗散有限制的问题
- 状态表示：`dp[i][j]`表示【集合】所有只从前 i 块能量石中选，总体积（**吃的时间**）~~不超过~~ $\to$ **恰好**为 j 的方案【属性】能量最大值
	- 吃的时间长了有可能**最大值还会减少**，**长时间**并不能囊括**短时间**的情况
- 状态计算：同01背包 `dp[i][j] = max( dp[i-1][j], dp[i-1][j - s[i]] + e[i] - (j - s[i]) * l[i] )` 前者不选第i个石头，后者不选第i个石头
	- 同样可同01背包将第1维压缩掉，因为用的都是i-1的状态
	- 最后就需遍历一遍整个dp取最大值作为最终答案

#### 实现
- 排序比较时，不应该写成除法，因为L可能是0；所以其实不管变不变形，都能写比较器的