## 遍历

### 846. 树的重心

- 树重心的定义：删除重心后，剩余各连通块节点数的最大值最小（即尽可能拆得均匀）
  - dfs遍历可以求每个子树的节点个数
  - dfs遍历：知左子树节点数，知右子树节点数，则也可知将自己这颗子树删去后剩余全树的节点数
- 所以可知，一次树的dfs遍历即可求出各节点删除后各连通块中点数最大的值

### 847.图中点的层次

有重边和自环的图，求从1号点走到n号点的最短距离：可以用bfs求

### 848. 拓扑序列

略了略了

不过回忆一下，有两种写法：

- 正向的bfs
- dfs后反向输出；反向dfs

## 最短路 SP

分类

- 单源最短路
  - 全部正权边
    - 朴素Dijkstra : O(n^2)
    - 堆优化Dijkstra : O(m log n)
  - 存在负权边
    - Bellman-Ford : O(nm)
    - SPFA : 优化Bellman-Ford 平均O(m)，最坏O(nm) 不一定都能做，要求不能有负环
- 多源汇最短路
  - Floyd算法

注意点

- 认为稀疏图是 m ~ n，是比较常见的理解
- 考察难点：如何建图，如何将问题抽象为最短路
- Dijstra基于贪心，Floyd基于dp，Bellman-Ford基于离散数学

### 849. Dijkstra求最短路I

- 邻接矩阵存图
- 处理重边和自环：重边取最小，自环无用

复杂度

- 不在set中的距离最近的点 O(n*n)
- 将选定的t加入set中 O(n*1)
- 用t更新其他点的距离(与t临界的) O(m)

### 850. Dijkstra求最短路II

稀疏图，堆优化方式

- 手写堆，能维持n个数（支持修改操作）
- STL优先队列，不支持更新指定元素，所以每次更新就插入新值，所以堆中元素个数可能到m个

复杂度

- 不在set中的距离最近的点 O(n*1)
- 将选定的t加入set中 O(n*1)
- 用t更新其他点的距离(与t临界的) O(m*logn)
  - 考虑到STL实现，堆中元素可能到m，则变为O(m*logm)；不过由于m<n^2所以有可以发现logm < 2logn = O(logn)，所以不管怎么样数量级不会变
  - 所以**一般就不用手写堆**了

语法

greater<>反而是小顶堆，稍微反语义直觉；默认less<>是大顶堆

```cpp
struct greater : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
// less 反一反
// 应该就是调用时，返回true就交换，所以greater时交换，就是小顶堆了
```

### 853.有边数限制的最短路

Bellman-Ford ： 这个真忘了

对于n点m边的图：循环n次，每次都对所有边 `a, b, w` 进行松弛操作 `d[b]=min(d[b], d[a] + w)`，这被称为三角不等式

有负权边：如果进一步有**负权回路**的图，则最短路不一定存在（负权环到不了的点就仍然存在）

- **外层迭代次数的含义**：循环k次后的 `d`，表示起始点经过不超过k条边的最短路
- 第n次更新时，如果还存在松弛操作，则说明有负环
  - 抽屉原理，说明存在一条最短路径有n条边，则对应n+1个点，而总共n个点，必有两个点相同，则说明**最短路径中成环**了，最短路径中有环则必然是负环了

实现

- 虽说k次循环后，d表示不超过k条边的最短路，但这只是针对正确的最短路；超过k条边的非法最短路d值可能会串联着被更新，原因在于可能后更新的d直接使用本轮的更新结果，导致1轮更新多轮效果
  - 输入样例：可能迭代一轮就d[1] d[2]就都出来了，只不过d[1]是合法确定的最短路，d[2]则不是
  - => 所以每轮要记录更新前的副本，每次更新仅用上一轮的结果
- 这道题是Bellman-ford变种，并不是完全一样的

### 851. SPFA求最短路

对Bellman-Ford的优化

- 对于其中的更新操作，d[b]被松弛更新当且仅当d[a]被松弛更新，所以按更新序遍历就可以一轮更新多轮（其实853已经能意识到，但853得避免这种情况）
- BFS遍历：queue中存可能可以更新的点，初始为起点1，每次更新一个点后，将这个点所有邻接点加入queue中

SPFA一般也可过dijkstra的正权图，可优先考虑；且一般情况更快（此题交850，快200ms）；网格图容易卡SPFA

- https://www.zhihu.com/question/292283275/answer/484871888

### 852. SPFA求负环

`dist[x]` 表示1起点到x的最短路；`cnt[x]` 当前最短路的边数

- 则cnt[x]大于等于n时，就相当于bellman-ford循环n次没有停；所以同理可知**路径中存在环**，即负环

实现

- 队列的实现：这题用STL就过了，子实现queue M<<1/2/3/4的大小都不够(?)，会越界段错误：最终 `q[M * 1000]` 过了，相当于 O(m n) 最坏情况，自己的queue记得开到最坏情况
- 问的是全图是否存在负权环，并不是从1出发的最短路中是否有负环；所以一开始将所有点加入队列；否则可能起点1不可达负环，从而漏掉此负环判断

### 854. Floyd求最短路

实现

- 注意存在重边和自环，都是需要处理一下的：重边取最小，自环本来就是0
- 注意存在负边，只不过没有负环，所以输出还是要小处理一下 > INF/2
- 其实就是由 `dp[k][i][j] = dp[k-1][i][k] + dp[k-1][k][j]` 优化而来；`dp[k][i][j]` 表示从 i 到 j 只经过1,2,..,k 中转可得的最短路
  - 所以压缩后，k循环也应该在外侧；problem中第二个样例就是顺序错导致的

## 最小生成树 MST

- Prim
  - 朴素 O(n^2)
  - 堆优化 O(m logn) 不常用
- Kruskal ：O(mlogm) = O(mlogn) 关键路径在排序

常用：稠密图 - Prim朴素； 稀疏图 - Kruskal （因为简单些）

### 858. Prim算法求最小生成树

朴素的Prim：则用邻接图存储

- 总共n轮
- 每轮将距离集合最近的一个点加入MST集合 O(n^2) -> O(m log n)
- 然后更新剩余点到集合的距离 O(n)

实现

- 注意考虑自环：自环不加入最小生成树，
- 不过此时自环可以不处理：点被选前，自环并不会加入“选最小距离”的比较中；点被选后，就不会再被选中则自环同样不起作用（不过这样就要注意，必须将点加入集合后再去更新，顺序不能反；否则更新遍历到   `g[t][t] 时可能会被权更小的自环修改` `d[t] `
- 这回我的bug是手残 N = 500 忘拓展导致的

堆优化：一样

### 859. Kruskal算法求最小生成树

Kruskal：稀疏图常用，简单

- 将所有边按权重从小到大排序 O(mlogm) 瓶颈，但是常数很小（快排）
- 顺序枚举每条边，若不连通则将其加入集合中（并查集）  O(m)

## 二分图

- 判断是否是二分图： 染色法 O(n+m)
- 求二分图最大匹配： 匈牙利法 最坏O(mn)  实际远小于此
  - 最大流算法理论和实际复杂度也类似此

### 860. 染色法判定二分图

tmp

### 861. 二分图的最大匹配
