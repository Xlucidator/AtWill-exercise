## 背包九讲

### 2. 01背包

每个物品只有1件

`dp[i][j]`

- 状态表示：【集合】在前i个物品中，装入总体积不超过j的选法；【属性】价值最大的选法
- 状态计算：`dp[i][j]`表示的集合可划分为 { 不选物品i, 选物品i }
  + 选0个物品i： = `dp[i-1][j]`
  + 选1个物品i： = `dp[i-1][j-volume[i]] + weight[i]` 且要合法（即体积合法）
- 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )`
- 代码优化，压缩存储 `dp[j]`，将原先第一维直接抹去，所以需要考虑状态的更新问题 `dp[j]` 包含沿途 `i=1 ~ n`的状态值

### 3. 完全背包

每个物品有无限件

> 注意：不能简单的根据性价比排序（weight/volume）后依次贪心选取，因为对于性价比相同的物品，如何选择是依赖于别的物品的，还是得dp

`dp[i][j]`

+ 状态表示：同上
+ 状态计算：`dp[i][j]`表示的集合可以划分为 { 选0/1/2/../k/../最满 个物品i }
  - 选0个物品i： = `dp[i-1][j]`
  - 选k个物品i： = `dp[i-1][j-k*volume[i]] + k * weight[i]` 且要合法
+ 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i], ..., dp[i-1][j-k*volume[i]] + k*weight[i], ... ), `
  - 观察 `dp[i][j-weight[i]]`可优化公式为 `dp[i][j] = max( dp[i-1][j], dp[i][j-weight[i]] + weight[i] )`
+ 代码优化 `dp[i]`，观察其与01背包的区别，唯一不同仅在 `dp[i][j-weight[i]]`的第一维，此处直接用到了[i]当前状态，而不是[i-1]上一轮状态，所以无需向01背包那样内循环逆序**以避免覆盖上一个状态的值**，可直接正向循环，因为用到的i状态就在此前更新

```
0-1背包:    dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )
完全背包:    dp[i][j] = max( dp[i-1][j], dp[ i ][j-volume[i]] + weight[i] )
```

### 4. 多重背包

每个物品有指定数量件

上限：物品种数n，背包容量m，物品数量p

#### I 数据范围100,100

基本3重循环dp, $O(mnp)$

#### II 数据范围1000, 2000

二进制优化

基本思路：将数量拆分，构成01背包

- 有s个就拆分为s件物品，就可以变为01背包，但这样拆依旧会超时：2000 -> 2000个， 最多可生成 2000 * 1000 个物品，再$n^2$算法就超了， 具体即 $O((np)\cdot m)$和最基本的算法一样
- 根据二进制表示拆分，7 -> 1 2 4, 8-> 1 2 4 8，这样就是$O(n \log p \cdot m)$ ，但这样也不对，因为可以表示出比原来还多的数量 $\to$ 拆分的最后一个仅为余出来的数 8 -> 1 2 4 1, 10 -> 1 2 4 3

代码优化：分开的vector不如和起来的vector，使用现成的pair似乎不如自己简单定义的结构体（不过要使用‵emplace_back`的话要把用到的构造函数定义一下）

#### III 数据范围1000, 20000

单调队列优化

从I朴素的dp思路开始，**参考完全背包问题的归纳**

```
完全背包
dp[i][j  ] = max( dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, ... , dp[i-1][j-kv]+    kw, ... )
dp[i][j-v] = max(             dp[i-1][j-v]  , dp[i-1][j-2v]+ w, ... , dp[i-1][j-kv]+(k-1)w, ... )
所以 dp[i][j] = max( dp[i][j], dp[i][j-v]+w )

多重背包
dp[i][j   ] = max( dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, ... , dp[i-1][j-sv]+    sw )  # s项
dp[i][j- v] = max(             dp[i-1][j-v]  , dp[i-1][j-2v]+ w, ... , dp[i-1][j-sv]+(s-1)w，dp[i-1][j-(s+1)v]+sw )  # s项
dp[i][j-2v] =
dp[i][j-3v] = 
...

记 r = j % v，则要求的每个点是 r, r+v, r+2v, .., j-v, j
dp[i][j   ]： 算从j开始向前的s个点（窗口大小 = s+1）
dp[i][j- v]： 算从j-v开始向前的s个点
...
对于每一项，都是求了长度为s的窗口内所有点的max值(当然还有偏移值w)；(特殊情况，前面的数不足填满窗口了，那就不算)
此即滑动窗口问题：
    154.滑动窗口：在线性时间求出所有滑动窗口的最大值，记滑动窗口大小为k，数据量为n，则单调队列优化将复杂度从O(nk)优化到O(n)
如此，便可将计算dp[i][]的复杂度从O(vs)优化到O(v)

```

从窗口的视角看

- 完全背包问题：`dp[i][xx]`每项求的都是**前缀**的最值
- 多重背包问题：`dp[i][xx]`每项求的是**滑动窗口**的最值

### 5. 分组背包

给物品分组，同组物品只能选一个，组间随意

此处“组”可以看作之前01背包的“物品”，只不过这个“物品”的属性并不单一，可以有多种形态(倒有点union的感觉)；那么每组选哪种形态 $\iff$ 多重背包时每个物品选几个（选几个构成的v,w就是该组选择物品的形态），所以完全可以当作**多重背包I**来做（多重背包是分组背包的特殊情况，因为特殊所以可以用二进制优化等）

所以似乎没有很好的优化方法，就只有朴素的三重循环

### 6. 二维费用背包

即多了一维费用

本身很简单，但变形想不清楚的话也做不来，见1020潜水员

### 7. 背包问题求方案数

求最优选法（价值最大的）的方案数量

这和278的和为M的组合数还是有不同，因为最大的情况是未知的，还需要标准dp求出

`cnt[i][j]` ：前i个物品，小于等于体积j的情况下最大价值的方案数

- 对于 `dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w)` ：选择了哪一边就继承哪一边的方案数，`cnt[i-1][j]`或 `cnt[i-1][j-v]`；若两边相同，则同时继承两边，即两者加和 `cnt[i-1][j] + cnt[i-1][j-v]` 

### 8. 背包问题求具体方案

变为求具体的方案，此处还需满足最小字典序（输出最小字典序的方案）

- 路径要记录，不再能压缩数组了
- 最小字典序，要从前往后选（从前往后，能选就选）：所以不妨背包第一维 `i`加物品时，从后往前看（这样最后得到的 `dp[1][V]`就是最终方案，即可从1开始向后判断是否选择物品）

```
30 300
59 113
92 144
95 74
6 3
44 89
8 11
77 214
60 169
37 110
49 127
21 36
57 80
84 49
16 33
27 69
57 78
70 193
47 131
16 11
44 75
44 39
93 89
74 190
34 100
78 207
2 5
74 181
25 38
46 104
55 85

输出 8 9 10 17 18 24 26 
```

错误写法，错因

- 因为不是压缩形势的dp，所以不能省略 `j < v[i]`的情况（需要将 `[i-1]`前一个值赋给 `[i]`
- 可以记录选择的信息可以和dp合在一起的，每次都是能选就选的策略即可
