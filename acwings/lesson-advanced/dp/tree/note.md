## 树形DP

dp的更新以树形进行： 因为数据的依赖结构也是树形的



### 285.没有上司的舞会

人之间以上司下级的关系成树的关系。
每个人有高兴值，参加舞会的不能有上司关系；要高兴值和最大

上司关系 <=> 树边；所以没有上司即所选的节点之间没有树边存在

- 状态表示 `dp[u][2] `，分成两个类别
  - 【集合】`dp[u][0]` 所有从以u为根的子树中选择，并且**不选u这个点的方案**；`dp[u][1]` 所有从以u为根的子树中选择，且**选u点的方案** 
  - 【属性】max
- 状态计算：记u的子节点为s1, s2, .. sn 一般记为si；计算顺序即从叶子到根
  - 不选自己，`dp[u][0] = \sum max(dp[si][0], dp[si][1])`
  - 选自己，`dp[u][1] = \sum dp[si][0]`
  - 复杂度：dp数组有2n个状态，每次更新复杂度都与儿子数量有关，总和即树的边数，所以更新枚举的次数是$O(n-1)=O(n)$ 

树的结构用链表存, 从叶子开始的话就用dfs