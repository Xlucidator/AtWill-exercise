## 背包九讲

### 2. 01背包
每个物品只有1件

`dp[i][j]`
- 状态表示：【集合】在前i个物品中，装入总体积不超过j的选法；【属性】价值最大的选法
- 状态计算：`dp[i][j]`表示的集合可划分为 { 不选物品i, 选物品i }
    + 选0个物品i： = `dp[i-1][j]`
    + 选1个物品i： = `dp[i-1][j-volume[i]] + weight[i]` 且要合法（即体积合法）
- 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )` 
- 代码优化，压缩存储 `dp[j]`，将原先第一维直接抹去，所以需要考虑状态的更新问题 `dp[j]` 包含沿途`i=1 ~ n`的状态值

### 3. 完全背包
每个物品有无限件

> 注意：不能简单的根据性价比排序（weight/volume）后依次贪心选取，因为对于性价比相同的物品，如何选择是依赖于别的物品的，还是得dp

`dp[i][j]`
+ 状态表示：同上
+ 状态计算：`dp[i][j]`表示的集合可以划分为 { 选0/1/2/../k/../最满 个物品i }
    - 选0个物品i： = `dp[i-1][j]`
    - 选k个物品i： = `dp[i-1][j-k*volume[i]] + k * weight[i]` 且要合法
+ 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i], ..., dp[i-1][j-k*volume[i]] + k*weight[i], ... ), `
    - 观察`dp[i][j-weight[i]]`可优化公式为 `dp[i][j] = max( dp[i-1][j], dp[i][j-weight[i]] + weight[i] )`
+ 代码优化 `dp[i]`，观察其与01背包的区别，唯一不同仅在`dp[i][j-weight[i]]`的第一维，此处直接用到了[i]当前状态，而不是[i-1]上一轮状态，所以无需向01背包那样内循环逆序**以避免覆盖上一个状态的值**，可直接正向循环，因为用到的i状态就在此前更新

```
0-1背包:    dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )
完全背包:    dp[i][j] = max( dp[i-1][j], dp[ i ][j-volume[i]] + weight[i] )
```

### 4. 多重背包
每个物品有指定数量件

上限：物品种数n，背包容量m，物品数量p

#### I 数据范围100,100
基本3重循环dp, $O(mnp)$


#### II 数据范围1000, 2000
二进制优化

基本思路：将数量拆分，构成01背包
- 有s个就拆分为s件物品，就可以变为01背包，但这样拆依旧会超时：2000 -> 2000个， 最多可生成 2000 * 1000 个物品，再$n^2$算法就超了， 具体即 $O((np)\cdot m)$和最基本的算法一样
- 根据二进制表示拆分，7 -> 1 2 4, 8-> 1 2 4 8，这样就是$O(n \log p \cdot m)$ ，但这样也不对，因为可以表示出比原来还多的数量 $\to$ 拆分的最后一个仅为余出来的数 8 -> 1 2 4 1, 10 -> 1 2 4 3

代码优化：分开的vector不如和起来的vector，使用现成的pair似乎不如自己简单定义的结构体（不过要使用‵emplace_back`的话要把用到的构造函数定义一下）

#### III 数据范围1000, 20000
单调队列优化


### 5. 分组背包
给物品分组，同组物品只能选一个，组间随意

此处“组”可以看作之前01背包的“物品”，只不过这个“物品”的属性并不单一，可以有多种形态(倒有点union的感觉)；那么每组选哪种形态 $\iff$ 多重背包时每个物品选几个（选几个构成的v,w就是该组选择物品的形态），所以完全可以当作**多重背包I**来做


### 6.