## 线段树

维护区间信息

### 原理

基本操作

- pushup ： 由子节点算父节点区间值
- pushdown ： 将父节点的修改信息下传到子节点，称为懒标记/延迟标记

线段树：除最后一层节点外，都是满二叉树，所以可以类似堆的存储方式，用一维数组存整颗树

- 每层对半分，m = $\lfloor (l + r) / 2 \rfloor$， 然后分为 $[l, m]$ 和 $[m+1, r]$ 
  - u的左孩子 `u << 1`，u的右孩子`u << 1 | 1` 
- 拆分到单点为止 
- 叶节点一定有n个；记线段树中**满二叉树部分**最底层有n节点
  - 最好情况：刚好是满二叉树，就是最后一层n个点，则全树就是2n-1个点
  - 最坏情况下：满二叉树下面一层还有接近满的最后一层，则最后一层最多2n个点，全数最多(2n-1) + 2n = 4n-1个点  （？？？ 怎么有点不对劲，我认为其实应该2n就够呀
  - 一般线段树开空间会开节点数的4倍

最简单的线段树，包含方法

- build() 将一段区间初始化为线段树
  - 根据定义，对半分递归构建
- query(l, r) 查询
  - $[l, r] \supset [T_l, T_r]$ ，即落在节点表示的区间范围内 ，则无需递归直接返回
  - $[l, r] \cap [T_l, T_r] \neq \varnothing$ ，则根据交集位置进行递归，左侧有就向左，右侧有就向右
  - 最开始一定会有交集，随着递归的发生不可能出现两个区间完全不相交（这样就不会去递归它了）
  - 复杂度：对于短区间，可能会正常一个一个看比较慢；但是**查询一次访问的区间数量**为O(logn) 
    - 分析递归情况：每种情况递归都不会无限开叉（**仅常数次开叉**），因而访问区间数还会是在O(logn)的量级，常数大概为4，即约4logn的区间数量。**常数有些大** 
      ![query](./query.png) 
    - 对于情况③，就最多开叉1次；对于情况②，开叉后一侧必然马上终止，相当于每开叉
- modify() 修改单点(易)，某个区间(难)
  - 单点修改：从根向下递归到点，然后回溯时pushup更新父节点的值（重新算一遍即可）
  - 区间修改 


  next



### 1275. 最大数

操作1：向序列尾加一个数  => 追加区间似乎不太好做，那么**就事先开好区间** => 在某位置修改一个数

操作2：求后L个数的最大值 => 询问 [n-l+1, n]区间的最大值

因而就能规约到**维护区间最大值的线段树**；

>  同时因为每个位置上的数只修改一次，所以本可以用RMQ倍增做，静态处理
>
> 不过因为输入的数是依赖于之前的操作，属于动态过程，所以不能用RMQ做了

如何确定线段树node中存什么信息：求区间的**某种属性**，一些**辅助信息**（视：当前区间的属性能否有子区间的属性算出，如果不能就可能需要增加）

**修改单点**的线段树，都不需要懒标记；修改区间的就需要，否则会退化

实现

- 注意A操作两数相加可能溢出，对于int来说溢出是负数，取模后仍是复数，则会存入负数；所以应该在相加后强制转换为unsigned int，这样取模后就是正数了：`modify(1, ++n, (unsigned)(x + last) % p)` 



### 245. 你能回答这些问题吗

操作1：查询区间中最大连续子段和

操作2：修改单点

### 246. 区间最大公约数

