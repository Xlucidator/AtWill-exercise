### T1 金色传说

写的时候确实对卡包的按b进行了排序，但是之后还是只想到枚举组合数(非排列)进行判断，想着做点很小的剪枝，但最终无用

- 滑动窗口+优先队列枚举，没能想清
    - 排序后，价格和可以到达最小值 = max(bi) - min(bi)，而总和不变；因而题目变为找k个卡包，使得a的总和最大，**b的极差最小**(这个我当时也没意识到，稍微一想就该知道的)
    - 总而只需枚举选定两个极差，即排序后跨度大于等于k的两个卡包，再从中间选出a最大的k-2个卡即可
    - 确定左侧卡包，然后将右侧卡包依次向右移动，维护滑动窗口记录中间k-2个最大的a；由于是要有k-2大的数，因而就不是单调队列能解决的了，用优先队列存
    - 复杂度：两侧卡包的枚举(滑动窗口也是要操作的，所以还是完整的组合枚举)为 $O(n^2)$ ，然后滑动窗口单次操作logk，因而总复杂度为 $O(n^2\log k)$ 这题常数小其实可以
- 动态规划：仍然是基于排序后堆b的认知
    - `dp[i][j]`记为前i个卡牌中选择j个，**且暂时未减去最大b值**的max答案。即最终答案一定是形如 `res_a - (b_r - b_l) = res_a + b_l - b_r`，从上个算法的实现中也可以发现，枚举时l一般不动，而r在变化；所以设置dp含义时也可暂时先不减取这个最大的`b_r`
    - 状态计算：
        - 初始状态 `dp[i][1] = max(dp[i-1][1], a[i] + b[i])`，此时本身为非法状态，这个b[i]即为b_l，必然作出正向贡献
        - j>2普通状态 `dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + a[i])`，前者是不选第i个卡包，后者是选择第i个卡包
    - 最终答案就是`dp[i][k] - b[i]`中取最小 -> 很不对，没有记录最右侧的选择信息啊? -> 如果没有选i卡包的情况被减去了b[i]（假设所选最后的卡包为t），那么值必然不如`dp[t][j]`再减去b[t]的值，因为a之和没有变，但是b却多减了。**所以没问题** 

