## 背包九讲

### 2. 01背包
每个物品只有1件

`dp[i][j]`
- 状态表示：【集合】在前i个物品中，装入总体积不超过j的选法；【属性】价值最大的选法
- 状态计算：`dp[i][j]`表示的集合可划分为 { 不选物品i, 选物品i }
    + 选0个物品i： = `dp[i-1][j]`
    + 选1个物品i： = `dp[i-1][j-volume[i]] + weight[i]` 且要合法（即体积合法）
- 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )` 
- 代码优化，压缩存储 `dp[j]`，将原先第一维直接抹去，所以需要考虑状态的更新问题 `dp[j]` 包含沿途`i=1 ~ n`的状态值

### 3. 完全背包
每个物品有无限件

> 注意：不能简单的根据性价比排序（weight/volume）后依次贪心选取，因为对于性价比相同的物品，如何选择是依赖于别的物品的，还是得dp

`dp[i][j]`
+ 状态表示：同上
+ 状态计算：`dp[i][j]`表示的集合可以划分为 { 选0/1/2/../k/../最满 个物品i }
    - 选0个物品i： = `dp[i-1][j]`
    - 选k个物品i： = `dp[i-1][j-k*volume[i]] + k * weight[i]` 且要合法
+ 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i], ..., dp[i-1][j-k*volume[i]] + k*weight[i], ... ), `
    - 观察`dp[i][j-weight[i]]`可优化公式为 `dp[i][j] = max( dp[i-1][j], dp[i][j-weight[i]] + weight[i] )`
+ 代码优化 `dp[i]`，观察其与01背包的区别，唯一不同仅在`dp[i][j-weight[i]]`的第一维，此处直接用到了[i]当前状态，而不是[i-1]上一轮状态，所以无需向01背包那样内循环逆序**以避免覆盖上一个状态的值**，可直接正向循环，因为用到的i状态就在此前更新

```
0-1背包:    dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )
完全背包:    dp[i][j] = max( dp[i-1][j], dp[ i ][j-volume[i]] + weight[i] )
```

### 4. 多重背包
每个物品有指定数量件

#### I 数据范围100,100
基本3重循环dp


#### II 数据范围1000, 2000
二进制优化

#### III 数据范围1000, 20000
单调队列优化


### 5. 分组背包


### 6.