## 最长公共子序列
长度

内容：似乎加一个辅助的数组指向上一个字符就可

### 3510
A串中字符不重复，于是就可以将A串中出现的“字符”用其“下标”代替(hash的意味)，如此将B串中对应字符均转换为下标，便可将问题转换为“求转换后B串的LIS”

- 注意B串中可能有A串中不存在的字符，则这些字符必然是“失配字符”，其实直接忽略即可
- 1e6的数据量，得用scanf，得用nlogn的LIS算法，即贪心二分（这个二分其是也不用自己写, `lower_bound`这个函数似乎可以）
    + 自己写的二分： 1460ms
    + 用vector和lower_bound： 2839ms 看起来STL还是会慢好多


### 2694
最长公共子序列的长度唯一，但是该长度的组成内容并不唯一

基础dp思路: `dp[i][j]`表示a[0,i]和b[0,j]的LCS
```c++
dp[i][j] = (a[i] == b[j]) ? dp[i-1][j-1] :
                            max(dp[i-1][j], dp[i][j-1]);

```

- 5000的数据量，对于时间复杂度倒是n^2无忧，但是不要忘了空间复杂度，如果用`uint8_t`数组存储的话，5000 * 5000 * 1B = 25MB，倒是在64MB内；用int数组的话是100MB就超了。而由于`dp[i][j]`存的是长度(5000以内)，`cnt[i][j]`存的是数量可能很大，所以断然不可用`uint8_t`存，所以不能用而为数组
- 考虑**滚动数组**，常用的空间优化手段：对于dp来说，如果每一个状态都仅与上一个（几个）状态相关，这样的话再之前的无用状态就不用存下来了，仅做个过渡就可以被覆盖
    + 可以将`dp[N][N]`优化为`dp[2][N]`仅存储2个状态， `dp[0][]`存`[i-1][]`,而`dp[1][]`存`[i][]`
- cnt的转移：要比dp的转移要稍微多考虑些
    + `a[i] == b[j]`时，此时必有`dp[i][j] = dp[i-1][j-1] + 1`, cnt数有来自左上角`cnt[i-1][j-1]`的贡献；但同样也可能来自左侧和上侧（只要dp值即长度一样，那就是可以算作构成的方式）
    + `a[i] != b[j]`时，此时`dp[i][j]`取`dp[i-1][j]`和`dp[i][j-1]`的大者，cnt数也就依次来自左侧或右侧
        - **但还需注意**， 如果`dp[i-1][j] == dp[i][j-1]`，即可以说明此时有`dp[i][j] = dp[i-1][j-1]`，左侧和上侧的cnt值可能有部分来自`dp[i-1][j-1]`，同种情形重复了，所以需要再去重`cnt[i-1][j-1]`

```
dp j
 i 0 0 0 0 0 0 
   0 1 1 1 1 1
   0 1 1 2 2 2 
   0 1 1 2 2 2 
   0 
   0
```