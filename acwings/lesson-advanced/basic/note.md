### 795. 前缀和

### 797. 差分

原数组区间加$\iff$差分数组两端做加减；原数组某点值$\iff$ 差分数组求前缀和

### 双指针算法

1. 两个序列两个指针：如归并排序
2. 一个序列两个指针：如快排，指向区间

```cpp
for (i = 0, j = 0; i < n; ++i) {
    while (j < i && check(i, j)) j++;   // O(n^2) -> O(n)

    // ...
}
```

T799 最长连续不重复子序列：序列长 n 的范围 1e5， 找出最长的不包含重复数字的连续子序列，输出长度

- 维护区间 `[l, r]` ，枚举r每轮依次向后，每轮中看是否有重复，有重复就将 `l` 也向后移直到没有重复；所以最多就是r移动n，l移动n，最多操作2n，复杂度O(n)

T800 数组元素的目标和：A[]用i，B[]用j，对于每个i，都找一个j使得 A[i] + B[j] >= x，这样当i增加时，j只能减少；时刻维持住即可。初始则i=0,j=m-1


### 位运算

1. 求n的二进制表示中第k位(从0开始，LSB是0)  `(n>>k) & 1`
2. 求n的二进制表示中最低位的1, lowbit(x)


### 离散化

整数保序离散化

值域很大(如$0 \~ 10^9$)，个数较少(如$0 \~ 10^5$)。所以将**大值域映射到小值域中**，方便hash。**离散化到对应坐标**  .

问题：

- 原数组a[]中可能有重复元素 ： 去重
- 如何快速映射: 快速算出 a[i] 离散化为何值： 二分

模板：将所有用过数先存入alls，排序去重，这样alls的下标就可作为离散化后的值（将松弛大的下标离散化为紧凑小的下标)

```cpp
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素
// unique会将区间内重复元素移至末尾，然后返回去重后有效区间的end()；因此之后的erase掉就可以了

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}

////////// 对于纯C数组
int alls[N], n;
sort(alls, alls + n);
len = unique(alls, alls + n) - a - 1;

int find(int x) { // 另一种写法
    return lower_bound(alls, alls + len, x) - alls + 1; // 映射到 1, 2, ..., len 所以+1
}

```

T802 区间和 - 离散化：数轴(-10^9 \~ 10^9)即下标，要求区间中数之和；不过能用到的坐标只有3*10^5 (变更操作用1个坐标，询问操作用2个坐标)。值域跨度大，但稀疏

- 前缀和：如果下标范围小
- 即将映射到小范围。用到的只有相对关系，没有绝对关系
- 映射后即可用前缀和思路

### 区间合并

1维区间

- 按区间左端点排序
- 从前向后扫描区间，时刻维护一个[st, ed]区间。则新扫描到的区间会和维护的区间有几种关系，分别更新/记录/即可
