## 背包九讲

### 2. 01背包
每个物品只有1件

`dp[i][j]`
- 状态表示：【集合】在前i个物品中，装入总体积不超过j的选法；【属性】价值最大的选法
- 状态计算：`dp[i][j]`表示的集合可划分为 { 不选物品i, 选物品i }
    + 选0个物品i： = `dp[i-1][j]`
    + 选1个物品i： = `dp[i-1][j-volume[i]] + weight[i]` 且要合法（即体积合法）
- 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )` 
- 代码优化，压缩存储 `dp[j]`，将原先第一维直接抹去，所以需要考虑状态的更新问题 `dp[j]` 包含沿途`i=1 ~ n`的状态值

### 3. 完全背包
每个物品有无限件

> 注意：不能简单的根据性价比排序（weight/volume）后依次贪心选取，因为对于性价比相同的物品，如何选择是依赖于别的物品的，还是得dp

`dp[i][j]`
+ 状态表示：同上
+ 状态计算：`dp[i][j]`表示的集合可以划分为 { 选0/1/2/../k/../最满 个物品i }
    - 选0个物品i： = `dp[i-1][j]`
    - 选k个物品i： = `dp[i-1][j-k*volume[i]] + k * weight[i]` 且要合法
+ 状态转移公式： `dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i], ..., dp[i-1][j-k*volume[i]] + k*weight[i], ... ), `
    - 观察`dp[i][j-weight[i]]`可优化公式为 `dp[i][j] = max( dp[i-1][j], dp[i][j-weight[i]] + weight[i] )`
+ 代码优化 `dp[i]`，观察其与01背包的区别，唯一不同仅在`dp[i][j-weight[i]]`的第一维，此处直接用到了[i]当前状态，而不是[i-1]上一轮状态，所以无需向01背包那样内循环逆序**以避免覆盖上一个状态的值**，可直接正向循环，因为用到的i状态就在此前更新

```
0-1背包:    dp[i][j] = max( dp[i-1][j], dp[i-1][j-volume[i]] + weight[i] )
完全背包:    dp[i][j] = max( dp[i-1][j], dp[ i ][j-volume[i]] + weight[i] )
```

### 4. 多重背包
每个物品有指定数量件

上限：物品种数n，背包容量m，物品数量p

#### I 数据范围100,100
基本3重循环dp, $O(mnp)$


#### II 数据范围1000, 2000
二进制优化

基本思路：将数量拆分，构成01背包
- 有s个就拆分为s件物品，就可以变为01背包，但这样拆依旧会超时：2000 -> 2000个， 最多可生成 2000 * 1000 个物品，再$n^2$算法就超了， 具体即 $O((np)\cdot m)$和最基本的算法一样
- 根据二进制表示拆分，7 -> 1 2 4, 8-> 1 2 4 8，这样就是$O(n \log p \cdot m)$ ，但这样也不对，因为可以表示出比原来还多的数量 $\to$ 拆分的最后一个仅为余出来的数 8 -> 1 2 4 1, 10 -> 1 2 4 3

代码优化：分开的vector不如和起来的vector，使用现成的pair似乎不如自己简单定义的结构体（不过要使用‵emplace_back`的话要把用到的构造函数定义一下）

#### III 数据范围1000, 20000
单调队列优化

从I朴素的dp思路开始，**参考完全背包问题的归纳** 
```
完全背包
dp[i][j  ] = max( dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, ... , dp[i-1][j-kv]+    kw, ... )
dp[i][j-v] = max(             dp[i-1][j-v]  , dp[i-1][j-2v]+ w, ... , dp[i-1][j-kv]+(k-1)w, ... )
所以 dp[i][j] = max( dp[i][j], dp[i][j-v]+w )

多重背包
dp[i][j   ] = max( dp[i-1][j], dp[i-1][j-v]+w, dp[i-1][j-2v]+2w, ... , dp[i-1][j-sv]+    sw )  # s项
dp[i][j- v] = max(             dp[i-1][j-v]  , dp[i-1][j-2v]+ w, ... , dp[i-1][j-sv]+(s-1)w，dp[i-1][j-(s+1)v]+sw )  # s项
dp[i][j-2v] =
dp[i][j-3v] = 
...

记 r = j % v，则要求的每个点是 r, r+v, r+2v, .., j-v, j
dp[i][j   ]： 算从j开始向前的s个点（窗口大小 = s）
dp[i][j- v]： 算从j-v开始向前的s个点
...
对于每一项，都是求了长度为s的窗口内所有点的max值(当然还有偏移值w)；(特殊情况，前面的数不足填满窗口了，那就不算)
此即滑动窗口问题：
    154.滑动窗口：在线性时间求出所有滑动窗口的最大值，记滑动窗口大小为k，数据量为n，则单调队列优化将复杂度从O(nk)优化到O(n)
如此，便可将计算dp[i][]的复杂度从O(vs)优化到O(v)

```
从窗口的视角看
- 完全背包问题：`dp[i][xx]`每项求的都是**前缀**的最值
- 多重背包问题：`dp[i][xx]`每项求的是**滑动窗口**的最值


### 5. 分组背包
给物品分组，同组物品只能选一个，组间随意

此处“组”可以看作之前01背包的“物品”，只不过这个“物品”的属性并不单一，可以有多种形态(倒有点union的感觉)；那么每组选哪种形态 $\iff$ 多重背包时每个物品选几个（选几个构成的v,w就是该组选择物品的形态），所以完全可以当作**多重背包I**来做（多重背包是分组背包的特殊情况，因为特殊所以可以用二进制优化等）

所以似乎没有很好的优化方法，就只有朴素的三重循环

### 6.