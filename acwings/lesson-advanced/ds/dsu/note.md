## 并查集

`p[x] = x`

- 判断x是否为树根：`p[x] == x`
- find 求x的集合编号：`while(p[x] != x) x = p[x];`
- union 合并集合

```cpp
int  find (int a) { /* ... */ }
void uunion(int a, int b) { p[find(a)] = find(b); }
```

#### 优化1：路径压缩

基本认为是$O(1)$；

但是其实是$O(log n)$，需要在加上按秩合并，才能真正算是$O(\alpha(n))$，无限近似于常系数数

```cpp
// recursive
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]); 
    return p[x];
}

// non-recursive
int find(int x) {
    // 836.cpp中的写法，似乎做不到路径上所有节点的压缩，并不对
    // 需要记录沿途的所有节点
    while (p[x] != x) stack.push(x), x = p[x];
    while (!stack.empty()) p[stack.pop()] = x;
}
```

#### 优化2：按秩压缩

很少写，优化不多

### 1250. 格子游戏

加入一条边后成环 $\iff$ 在加入边前，边的两个点已经在一个集合中

（其实也可用无向图的tarjan算法求全联通分量，不过小题大做

### 240. 食物链

大一暑假时应该做过，但是现在确实又不会了... 关键：并查集不仅存同类关系，被吃关系也一并入；但同时记录点之间的关系

每个点到根节点的距离：用于表示关系中的分类（同类/被吃），模3即循环

- 距离为 1：吃根
- 距离为 2：被根吃
- 距离为 0：同类

（距离取模表示关系其实就是自己做时的思考方向，但是就是没能最终成型）

所以这里不能路径压缩 -> 不，只要额外再来一个数组记录到根节点的距离，然后路径压缩时更新距离就行；而且单纯的并查集并不能自由的配置距离，必然需要辅助数组
