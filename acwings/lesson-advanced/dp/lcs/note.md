## 最长公共子序列
长度

内容：似乎加一个辅助的数组指向上一个字符就可

### 3510
A串中字符不重复，于是就可以将A串中出现的“字符”用其“下标”代替(hash的意味)，如此将B串中对应字符均转换为下标，便可将问题转换为“求转换后B串的LIS”

- 注意B串中可能有A串中不存在的字符，则这些字符必然是“失配字符”，其实直接忽略即可
- 1e6的数据量，得用scanf，得用nlogn的LIS算法，即贪心二分（这个二分其是也不用自己写, `lower_bound`这个函数似乎可以）


### 2694
最长公共子序列的长度唯一，但是该长度的组成内容并不唯一

基础dp思路: `dp[i][j]`表示a[0,i]和b[0,j]的LCS
```c++
dp[i][j] = (a[i] == b[j]) ? dp[i-1][j-1] :
                            max(dp[i-1][j], dp[i][j-1]);

```